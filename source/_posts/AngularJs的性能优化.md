---
title: AngularJs的性能优化
date: 2017-09-05 12:30:06
tags: [AngularJs,js,前端性能优化]
categories: [AngularJs,前端性能优化]
---

#### 前言

老生常谈，这是一篇关于优化的讨论。自从有了 React(R)以及 Vue(V)之后，AngularJs(A)就成为了众矢之的，被黑的体无完肤。这与整个前端圈子的浮躁和快速发展有关。在我看来，AngularJs 确实是有缺点的，但是不至于差到影响整个系统的功能，更不可能差到不能使用。大部分的性能差都是由于程序员自己的错误使用导致的。

#### 缺点

在我看来，它有以下几个缺点：

* 1.体积大
  A 的体积和 R 和 V 相比确实是比较臃肿，这与它的架构和帮开发者做的一些默认设定有关。从架构上来讲，今天看来 A 确实是不算优秀。但是，A 诞生于 2009 年，已经快 10 年了，在当年那个几乎刀耕火种的年代，它是一种巨大的进步。
* 2.超大规模应用的性能问题对于简单的小型应用，在各个框架的最佳实践下，A、R、V 甚至是 jQuery 都不会有太大的性能问题。但是，A 基于$digest 循环的脏值检查机制，在单页面中绑定数据量很多的情况下，确实会存在性能问题。这是底层架构决定的。而且这个绑定的数据量也是很难界定的，曾有人测试过对于 1.2 版本的 A 的性能上限是 2000 个左右。从目前我做过的项目来看，使用超过 3000 个数据绑定在同一页面都不会有太大的问题(1.5.8 版本)，这也与某些 A 模块的自我优化有关。

#### 解决办法

对于体积较大的 A，我的建议是不要考虑移动端的使用，只在 PC 端使用，当然现在 4G 确实已经很快了，如果是做 APP 的话还可以在本地加载，但是不可否认 A 的使用需要配合一系列的相关模块，总体下来还是有相当大的体积的。至于性能问题，A 这些年的自我发展和完善已经基本上填满了这些坑，只要按照官方的指导结合近年来的最佳实践，是基本不会有问题的。我也总结了几个我常用的方法：

* 1.一次性绑定貌似是从 1.3（不确定） 开始，A 内置了一次性绑定，使用方法是双冒号::,

  ```bash
  <span>{{ ::name }}</span>  or  <span ng-bind="::name"></span>
  ```

  众所周知，A 的性能问题是由于它的$digest 循环机制引起的，它采用$watch 来监视注册的$$watchers，对于 A 的脏检查机制(dirty-checking), 常见的误解就是认为： A 是定时轮询去检查 model 是否变更。其实，A 只有在指定事件触发后，才进入$digest cycle：

  * DOM 事件，譬如用户输入文本，点击按钮等。(ng-click)
  * XHR 响应事件 ($http)
  * 浏览器 Location 变更事件 ($location)
  * Timer 事件($timeout, $interval)
  * 执行$digest()或$apply()

  当上述事件发生时，A 就会进入$digest cycle，会检查所有注册在当前$scope 上的$$watchers 是否发生变化，并执行对应的回调函数（如果有的话）。所以$$watchers 的数量是会造成性能问题的。但是对于一般的应用来说，很多数据都是从后台获取到之后，就直接展示在页面上，并不会在进行改动的，这个时候如果用一次性绑定，就不会被添加到$$watchers 中，就不会增加每次$digest 的负担，性能就相应的提高了。这种不适用于实时的数据展示和会产生变动的数据，例如股票行情，表单数据等。
  V 中的单词绑定虽然原理跟这个不一样，但是也是相似的优化。

* 2.使用 track by
  这个目前是公认且大量使用的特性，三大主流框架中都有各自的实现和优化方式，基本都是为了最小化 DOM 操作的开销和 DOM 复用。

* 3.合理使用$watch,$watchGroup,$watchCollection
  这三个函数都是用来创建$$watchers 的，监视的数据如果发生变化了就会触发对应的回调，相当于添加了一个监视器，使用起来非常方便，但是数量过多时会造成性能负担。特别是$watch，如果第三个参数为 true 时，会对监控的对象深度遍历，性能极差。

* 4.合理使用 ng-if 和 ng-show
  这两个指令其实是适用于不同的场景的，理论上 ng-if 的性能是会比 ng-show 更好的，所以优先使用 ng-if。

* 5.ng-model 的防抖和节流这个功能是普遍表单等业务场景中都需要的。因为频繁的触发 ng-change 等事件不仅会造成网络和带宽上的浪费，也会造成过于频繁的执行$digest 循环造成性能问题，还有可能引起浏览器的 repaint。

* 6.根据路由懒加载资源（单页面）如果是大型的单页应用，经常会编写各式各样的模板来复用，对于不经常使用的模块和功能，是没有必要打在公共资源包里的，可以使用懒加载的方式，切换路由时再加载。这样可以加快整个应用的启动和响应速度（因为一开始初始化时要下载和执行的东西少），缺点是进行路由切换时有可能速度慢。

以上这些就是我在项目中常用的方法。虽然 A 的 1.x 版本已经有些老旧了，但是依然是不过时的，在不多数场景下使用是不存在什么问题的。
