---
title: JS引擎的执行机制
date: 2018-03-16 9:20:28
tags: [JS 基本原理]
---

### 前言

这是一篇关于 JS 引擎的个人理解和总结，文中多数是记录从大神那里学到的，加了少许自己的理解。

### 正文

要说 JS 引擎，听过最多的就是 JS 是单线程的。这句话很简洁，却也很容易误导人。经常有人把这句话理解成浏览器是单线程的。浏览器的线程管理是比较复杂的，之前曾经专门看过这个问题，有人说浏览器是客户端最复杂的应用，对此非常赞同，像 chrome 这种优化到极致追求性能又要保证用户体验的产品确实是难得的。有人说 chrome 占用内存太大，看看现在的 firefox 就知道了，想要做好的浏览器内存占用是不可避免的。关于浏览器的问题请简单参考[这里](http://www.cnblogs.com/wenanry/archive/2010/02/25/1673368.html)。
JS 是单线程语言，浏览器只分配给 js 一个主线程，用来执行任务（函数），但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行，但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。所以，浏览器为这些耗时任务开辟了另外的线程，主要包括 http 请求线程，浏览器定时触发器，浏览器事件触发线程，这些任务是异步的。事实上,按照异步和同步的划分方式,并不准确。而准确的划分方式是:

* macro-task(宏任务)：script (整体代码)，setTimeout, setInterval, setImmediate, I/O, UI rendering.
* micro-task(微任务)：process.nextTick, Promise(原生)，Object.observe，MutationObserver

{% img https://blog-1255356076.cos.ap-shanghai.myqcloud.com/386112937-5a5763d9ef823_articlex.png %}

按照这种分类方式:JS 的执行机制是

执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完重复以上 2 步骤,结合 event loop(1) event loop(2) ,就是更为准确的 JS 执行机制了。

### 总结

综上所述，在一些比较复杂的操作中，经常需要使用 setTimeout(0)来保证代码执行的顺序，这只是一种简化的做法，但是效果还是很好的。更加正规化的做法是通过 Promise 来保证执行顺序。
