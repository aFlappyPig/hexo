---
title: 关于CSRF
date: 2017-10-2 15:00:05
tags: [WEB安全]
---

### CSRF 简介

CSRF 是 {% link Cross-Site Request Forgery https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet %} 的简称，中文译为跨站请求伪造，也被称为单击攻击或者会话叠置，是一种恶意利用从网站信任用户获取未授权命令的行为。和跨站脚本(XSS)不同，XSS 利用的是特定站点信任的用户，而 CSRF 利用的是用户浏览器中信任的站点。

### CSRF 攻击原理

CSRF 攻击攻击原理及过程如下：

* 1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站 A；
* 2. 在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站 A 成功，可以正常发送请求到网站 A；
* 3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；
* 4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A；
* 5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

从以上原理可以看出，CSRF 是利用浏览器发起的代理人攻击。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用 POST 方式提交参数的页面。

### CSRF 防范

目前防御 CSRF 攻击有很多种策略，上面的链接中也讨论了多种方案。简单列举如下：

* 1.验证识别请求来源

  这里是指通过 Origin 头和 Referer 头来简单的验证该请求是否来自于受信任的安全站点，这种方法实现成本较低，但是不能 100%保证安全性，因为对于一些老旧浏览器是可以通过一些方法更改这些请求头的。主要方法服务端验证所有请求（也可以只验证增删改等敏感操作）的 Origin 和 Referer 头是否指向自家的网站地址，如果不是的话就拒绝请求即可。

* 2.同步器（CSRF）令牌

  通常，开发人员只需为当前会话生成一次令牌（登录时）。在初始生成此令牌之后，该值将存储在会话中，并用于每个后续请求，直到会话过期。当最终用户发出请求时，服务器端组件必须验证请求中令牌的存在性和有效性，与会话中找到的令牌相比较。如果在请求中找不到令牌，或者提供的值与会话中的值不匹配，则应中止请求。

* 3.自定义请求头这种防御依赖于同源策略（SOP）限制。默认情况下，浏览器不允许 JavaScript 发出跨源请求。目前使用最多的自定义头如下：
  ```bash
    X-Requested-With：XMLHttpRequest
  ```
  大多数 JavaScript 库已经将这个头添加到默认生成的请求中。这种方法具有双重优势，通常不需要 UI 更改，也不需要引入任何服务器端状态。

以上提到的方法并不全面，另有一些方法实现有些复杂并未提及。对于这些 CSRF 防范，前端能做的只是根据整个架构的方案进行配合，主要还是要靠服务端实现防御。服务端不同的语言的不同框架基本都有自己的实现和验证，基本都是默认开启的（方案 1）。方案二是目前我做过的项目用的最多的方法。一般做法是登录成功后服务端生成一个 token 给到前端，前端把这个 token 记录在本地，之后的每个请求都包含这个 token 在请求头之中，服务端接到请求后先进行 token 验证在处理请求。如果用户 session 过期，则退出登录重新获取。
